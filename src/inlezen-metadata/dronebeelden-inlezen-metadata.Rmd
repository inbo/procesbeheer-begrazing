---
title: "Verkenning inlezen en rekenen met dronebeelden"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = TRUE)

library(terra)
library(rprojroot)
library(tidyverse)
library(fs)
library(httr)
library(xml2)
library(dplyr)
library(sf)
source(find_root_file("src/utils/utils.R", criterion = is_git_root))
source(find_root_file("src/utils/geocomputations.R", criterion = is_git_root))
```



# Inlezen 



## Digitaal oppervlakte model (dronebeelden) (Digital Surface Model DSM)


### Rasterbeelden

Dronebeelden rechtstreeks vanaf gedeelde google drive via lokale sync in G:\


Voordelen:

- script blijft werken omdat iedereen naar dezelfde locatie verwijst (op voorwaarde dat G gekozen werd als schijf voor google drive lokaal te syncen)
- download vanaf google drive gebeurd automatisch, geen authentificatie nodig (google drive for desktop zal enkel die bestanden lokaal beschikbaar maken die effectief gebruikt worden)


```{r inlezen, warning=FALSE}
map_procesbeheer <- get_map_procesbeheer()
fs::dir_exists(map_procesbeheer)
all_tif_files <- fs::dir_ls(file.path(map_procesbeheer, "Drone_geg"), 
                            recurse = TRUE, 
                            glob = "*.tif")
walk(all_tif_files, load_tif)
```

```{r check-metadata}
X20200831_0179202_Ename1_DEM

cat(crs(X20200831_0179202_Ename1_DEM))
```


```{r}
plot(X20200831_0179202_Ename1_DEM)
```


### Dronevlucht polygonen

```{r droneblokken}
droneblokken <- read_sf(
  file.path(
    map_procesbeheer, "droneblokken", "20210429_DroneblokProcesbeheer.shp"
    ), crs = 31370
  )
```

```{r}
plot_gebied <- function(data, gebied) {
  data %>%
    ggplot() +
    geom_sf() +
    labs(title = gebied)
}

plot_df <- droneblokken %>%
  group_by(Gebied) %>%
  nest() %>%
  mutate(plot = map2(data, Gebied, plot_gebied))

plot_df$plot
```



## Digitaal terrein model (DTM)

Digitaal Hoogtemodel Vlaanderen II:

Zie WCS service:

https://inspire.informatievlaanderen.be/overdrachtdiensten/el-dtm/wcs?request=GetCapabilities


```{r}
# voorbeeldje
bbox_vec <- X20200831_0179202_Ename1_DEM %>%
  ext() %>%
  floor() %>%
  as.vector()

dtm1m <- get_wcs_layer(
  wcs = "dtm", 
  bbox = bbox_vec,
  layername = "EL.GridCoverage.DTM", 
  resolution = 1)

#all.equal(crs(dtm1m), crs(X20200831_0179202_Ename1_DEM))

plot(dtm1m)

```



## Canopy height model (CHM)

Canopy height model = digitaal oppervlaktemodel - digitaal hoogtemodel

*R*


```{r}
test_chm <- calc_chm(dsm = X20200831_0179202_Ename1_DEM) #enkele minuten

test_chm

plot(test_chm)

# opgepast! naam van blok (EN2) correspondeert niet met naam van tif bestand Ename1
rasterVis::gplot(test_chm) +
  geom_tile(aes(fill = value)) +
  scale_fill_gradient(low = 'white', high = 'blue') +
  geom_sf(data = droneblokken %>%
            filter(Gebied == "Ename"),
          aes(colour = naam), 
          fill = NA,
          inherit.aes = FALSE)


```


```{r plot3d, eval=FALSE}
rasterVis::plot3D(raster::raster(test_chm))
```


## NDVI 

Bron: false colour-NIR orthofoto van Informatie Vlaanderen (2018)

https://geoservices.informatievlaanderen.be/raadpleegdiensten/OMZ/wms

https://www.geopunt.be/catalogus/datasetfolder/5c3e8dd5-587a-4bab-b88a-ab3c9a2b6709

https://inspire.informatievlaanderen.be/overdrachtdiensten/oi-omz/wcs

Enkel CIR nodig om NDVI te berekenen. 
Zie https://eo.belspo.be/nl/kleurencomposieten:

> Een bijzonder doeltreffende kleurencomposiet in teledetectie is "valse-kleuren infrarood" beeld. Hierin worden de banden van nabij infrarood, rood en groen van de sensor geassocieerd met de kleuren rood, groen en blauw van het scherm. 

NDVI = (NIR - RED) / (NIR + RED)

De mapping is dus:

- NIR = nabij-infrarood = band1 = "rood op het scherm"
- RED = rood = band2 = "groen op het scherm"

```{r}
test_ndvi <- calc_ndvi(dsm = X20200831_0179202_Ename1_DEM)
plot(test_ndvi)
test_ndvi
```



## GRTS master sample

Zie https://inbo.github.io/n2khab/articles/v030_GRTSmh.html


```{r}
if (!file.exists("n2khab_data")) {
  n2khab::fileman_folders(root = "git")
  dir.create("n2khab_data/10_raw/GRTSmaster_habitats")
  n2khab::download_zenodo(doi = "10.5281/zenodo.2682323",
                          path = "n2khab_data/10_raw/GRTSmaster_habitats")
}

grts_mh <- n2khab::read_GRTSmh()
grts_mh <- terra::rast(grts_mh) 
# terra:rast reads crs from the tif file, not from the grts_mh object
# need to manually replace by correct crs representation
terra::crs(grts_mh) <- "EPSG:31370"
```

```{r}
plot(grts_mh)

#detail
grts_detail <- grts_mh %>%
  crop(ext(c(100000,100200,175000,175200)))
grts_detail_points <- as.points(grts_detail)

# check dat as.points() de centroÃ¯den geeft
plot(grts_detail)
points(grts_detail_points)


```

## Indelen in klassen en oppervlakte-aandelen bepalen 

Mbv exactextractr oppervlakte-aandelen bepalen in buffers rond grts punten.



```{r}
height_classification <- c(-Inf, 0, 0.07, 0.15, 0.25, 0.45, 0.70, 1, 1.5, 2,
                           2.75, 4, 8, +Inf)
ndvi_classification <- c(-1, 0, 0.1, 0.2, 0.3, 0.4, 1)
bufferdistance <- 5

test_ndvi_classes <- classify(test_ndvi, 
                              ndvi_classification,
                              include.lowest = TRUE)
plot(test_ndvi)
plot(raster_classes)

test_chm_classes <- classify(test_chm,
                             height_classification,
                             include.lowest = TRUE)
plot(test_chm)
plot(test_chm_classes)



debugonce(calc_bufferstats)
ndvi_ac <- calc_bufferstats(raster = test_ndvi, 
                  cuts = ndvi_classification,
                  grts_raster = grts_mh,
                  bufferdist = bufferdistance)

chm_ac <- calc_bufferstats(raster = test_chm, 
                  cuts = height_classification,
                  grts_raster = grts_mh,
                  bufferdist = bufferdistance)

```


# Resources

https://datacarpentry.org/r-raster-vector-geospatial/03-raster-reproject-in-r/

https://semba-blog.netlify.app/12/14/2020/manipulate-and-visualize-raster-data-with-leaflet-and-tmap-in-r/
