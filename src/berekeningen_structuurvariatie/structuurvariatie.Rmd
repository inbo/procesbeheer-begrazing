---
title: "Berekening van structuurvariatie op basis van dronebeelden en orthofoto's"
author: "Hans Van Calster"
date: "`r Sys.Date()`"
output: bookdown::pdf_document2
bibliography: references.json
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
library(knitr)
opts_chunk$set(echo = FALSE)


library(terra)
library(rprojroot)
library(tidyverse)
library(fs)
library(httr)
library(xml2)
library(dplyr)
library(sf)
library(geodiv)
library(mapview)
library(readxl)
library(stars)

source(find_root_file("src/utils/utils.R", criterion = is_git_root))
source(find_root_file("src/utils/geocomputations.R", criterion = is_git_root))
source(find_root_file("src/utils/wfs_wcs.R", criterion = is_git_root))

```

# Doelstellingen

-   Metrieken ontwikkelen voor structuurvariatie (ongeveer) op plotniveau (diameter 6 m).
-   Toe te passen op de plots (respons = fauna/flora) en op gebiedsniveau (relatie met begrazing): toch twee verschillende dingen
    -   plotniveau: maat voor variatie in structuur binnen de plot
        -   obv CHM
        -   obv combinatie CHM en NDVI
    -   gebiedsniveau: een kaart die de structuur weergeeft
-   Welke resolutie ??? Intuitief tussen 5 en 25 cm
    -   bij aggregatie opties van aggregeren bekijken (gemiddelde, low pass filter, high pass filter, ...)
-   CHM produceren: dtm wordt geïnterpoleerd
    -   dtm heeft resolutie 1m en moet op zelfde resolutie als CHM worden gebracht
-   Foutenanalyse op dtm op basis van rtk metingen van subplots !! (27 dtm pixels t.o.v. 5 manuele metingen)
    -   RTK metingen zitten in file geodatabank layer pb_subplot_center
    -   De vraag is hier of de RTK metingen systematisch verschillen van de DTM en indien ja of we de DTM metingen kunnen corrigeren hiermee
-   Als studiegebied in eerste instantie Ename !
    -   dronevluchtblokken binnen de studiegebieden zijn praktisch gekozen eenheden die de bedoeling hebben om een representatief beeld te hebben van de verschillen in structuurvariatie in het gebied
    -   De naamgeving van de drone-beelden van Ename is definitief aangepast: zie "/Procesbeheer/PB06_Drone_En_Beelden/PB_Drone_Data/Voedselrijk_Ename/Ename20200831"
    -   vh25 slaat op "vegetatiehoogte op een resolutie van 25 cm" (chm - dtm vlaanderen) en is dus een gemerged beeld van het hele gebied.

```{r inlezen-ename-rasters, warning=FALSE}
map_procesbeheer <- get_map_procesbeheer()
all_tif_files <- fs::dir_ls(file.path(map_procesbeheer, 
                                      "PB06_Drone_En_Beelden",
                                      "PB_Drone_Data",
                                      "Voedselrijk_Ename",
                                      "Ename20200831"), 
                            recurse = TRUE, 
                            glob = "*.tif")
all_ndvi_tif_files <- fs::dir_ls(file.path(map_procesbeheer, 
                                      "PB06_Drone_En_Beelden",
                                      "PB_NDVI"), 
                            recurse = TRUE, 
                            glob = "*.tif")

all_jpg_files <- fs::dir_ls(file.path(map_procesbeheer, 
                                      "PB06_Drone_En_Beelden",
                                      "PB_Drone_Data",
                                      "Voedselrijk_Ename",
                                      "Ename20200831"), 
                            recurse = TRUE, 
                            glob = "*.jpg")

walk(all_tif_files, load_rasterfiles)
walk(all_ndvi_tif_files[grepl("Ename", all_ndvi_tif_files)],
     load_rasterfiles)
walk(all_jpg_files, load_rasterfiles)
```

```{r inlezen-geodatabank}
gdb_file <- file.path(
  "Z:/Projects/PRJ_Procesbeheer/PBGIS05_Steekproef",
  "Procesbeheer_Design.gdb")

#file.exists(gdb_file)
#st_layers(gdb_file)

pb_plot <- read_sf(gdb_file, layer = "PB_Plot") %>%
  filter(Gebied == "Ename") %>%
  janitor::clean_names()

# de defaultwaarde voor TAW is ingesteld op 0 (bad practice!)
pb_subplot_center <- read_sf(gdb_file, layer = "PB_Subplot_Center") %>%
  janitor::clean_names() %>%
  filter(gebied == "Ename",
         taw > 0) %>%
  rename(x = x_lambert_cntr,
         y = y_lambert_cntr)
pb_gebied <- read_sf(gdb_file, layer = "PB_Gebied") %>%
  filter(Naam == "Ename") %>%
  janitor::clean_names()
pb_onderzoeksgebied <- read_sf(gdb_file, layer = "PB_Onderzoeksgebied") %>%
  filter(Gebied == "Ename") %>%
  janitor::clean_names()
```

# Berekening canopy height model (CHM)

## Digitaal terreinmodel (DTM) versus RTK hoogtemetingen

```{r rtk-plots-ename}
pb_subplot_center %>%
  ggplot() +
  geom_point(aes(x = x, y = y, size = taw)) +
  facet_wrap(~code_plot, scales = "free", labeller = label_both)
```

```{r wcs-dhm-ename}
# voorbeeldje
bbox_vec <- pb_subplot_center %>%
  st_buffer(dist = 100) %>%
  ext() %>%
  floor() %>%
  as.vector()

dtm_extent_rtk <- get_coverage_wcs(
  wcs = "dtm", 
  bbox = bbox_vec,
  layername = "EL.GridCoverage.DTM", 
  resolution = 1)

#all.equal(crs(dtm1m), crs(X20200831_0179202_Ename1_DEM))
```

Bepaling TAW op basis van DTM.

```{r}
taw_dtm <- terra::extract(dtm_extent_rtk,
               vect(pb_subplot_center),
               method = "simple") %>%
  as_tibble()
colnames(taw_dtm) <- c("id", "taw_dtm")

rtk_ename_dtm <- pb_subplot_center %>%
  bind_cols(taw_dtm %>%
              select(taw_dtm)) %>%
  mutate(taw_verschil = taw - taw_dtm)

rtk_ename_dtm %>%
  ggplot(aes(x = code_plot, y = taw_verschil)) +
  geom_hline(yintercept = 0) +
  geom_point(alpha = 0.3) +
  stat_summary(fun.data = mean_cl_boot, colour = "orange") +
  labs(y = "Verschil in meter t.o.v. DTM")
```

```{r eval=FALSE}
raster::raster(dtm_extent_rtk) %>%
  mapview(alpha = 0.3,
          maxpixels = 1e6)

raster::raster(Ename_20200831_DEM_Blok1) %>%
  mapview(alpha = 0.3,
          maxpixels = 1e6)
```

```{r plot-droneblokken-ename}
pb_onderzoeksgebied %>%
  ggplot() +
  geom_sf() +
  geom_sf(data = pb_subplot_center,
          aes(colour = code_plot), size = 4)
```

```{r vh25-rtk}
ggplot() +
  geom_stars(data = st_as_stars(Ename_20200831_vh25),
             downsample = 11) +
  coord_equal() +
  geom_point(data = pb_subplot_center,
             aes(x = x, y = y, colour = code_plot),
             size = 4)
```

## Keuze resolutie en (dis)aggregatiemethoden

Probleem:

-   DSM dronebeelden hebben hoge resolutie met resolutie 0.025 m x 0.025 m
-   DTM raster heeft een resolutie van 1 m x 1 m

Het canopy height model wordt berekend door verschil te berekenen tussen het DSM en DTM.
Om deze berekening te kunnen doen moeten beide rasters op eenzelfde rastergrid geplaatst worden (zelfde oorsprong, oriëntatie en resolutie).

Vanuit theorie over foutenpropagatie zou je voor de berekening van dit verschil, de resolutie moeten overnemen van het minst nauwkeurige raster.
Indien je dat niet doet, introduceer je schijnnauwkeurigheid door het minder nauwkeurige raster voor te stellen op een fijnere resolutie.
Voor maaiveldhoogte is het risico op introductie van grote fouten hierop echter erg laag.
De maaiveldhoogte wijzigt meestal niet veel op afstanden minder dan 1 meter.
Bovendien kan er bij de disaggregatie eventueel gekozen worden voor bilineaire interpolatie zodat de geïnterpoleerde waarden een gemiddelde is van een lineaire regressie van de oorspronkelijke celwaarden in de x- en in de y-richting.

Vanuit ecologisch perspectief zijn we geïnteresseerd in structuurvariatie ten gevolge van hoogteverschillen in het vegetatiedek ten opzichte van het maaiveld.
Hiervoor is een resolutie nodig die fijn genoeg is om deze patronen realistisch te weerspiegelen en deze resolutie zit waarschijnlijk ergens tussen deze van het DSM en deze van het DTM.
Er zal dus een aggregatie nodig zijn van het DSM en een disaggregatie van het DTM.
We stellen de gewenste resolutie in op verschillende waarden en gaan na vanaf wanneer de relatie met de RTK hoogtemetingen te sterk uitgemiddeld wordt.

```{r}
chm_res <- c(0.1, 0.25, 0.5, 1)

chm_b1 <- map(chm_res,
              function(x) {
                calc_chm(dsm = Ename_20200831_DEM_Blok1,
                        chm_resolution = x,
                        dtm_resolution = 1)
              })

chm_b2 <- map(chm_res,
              function(x) {
                calc_chm(dsm = Ename_20200831_DEM_Blok2,
                        chm_resolution = x,
                        dtm_resolution = 1)
              })

chm_b3 <- map(chm_res,
              function(x) {
                calc_chm(dsm = Ename_20200831_DEM_Blok3,
                        chm_resolution = x,
                        dtm_resolution = 1)
              })

chm_b4 <- map(chm_res,
              function(x) {
                calc_chm(dsm = Ename_20200831_DEM_Blok4,
                        chm_resolution = x,
                        dtm_resolution = 1)
              })

chm_b5 <- map(chm_res,
              function(x) {
                calc_chm(dsm = Ename_20200831_DEM_Blok5,
                        chm_resolution = x,
                        dtm_resolution = 1)
              })

chm_b6 <- map(chm_res,
              function(x) {
                calc_chm(dsm = Ename_20200831_DEM_Blok6,
                        chm_resolution = x,
                        dtm_resolution = 1)
              })
```

```{r}
chm_b1
```

## Berekening CHM en overlappende blokken

Dit kan met `terra::merge` of `terra::mosaic`.
In het eerste geval wordt bij overlap tussen verschillende rasters voorrang gegeven aan de eerste raster, dan de tweede, ... die wordt doorgegeven aan de functie.
De functie `terra::mosaic` zal daarentegen een gemiddelde (of andere aggregatiefunctie) nemen bij overlappende delen.

```{r}
mosaicname <- file.path(get_map_procesbeheer(),
                       "PB06_Drone_En_Beelden",
                       "PB_afgeleide_data",
                       "chm",
                       paste0("Ename_20200831_CHM_mosaic",
                              "_res",
                              "0.25",
                              ".tif"))

```

```{r mosaic-res0.25, eval=!file.exists(mosaicname)}
terra::mosaic(
  chm_b1[[2]],
  chm_b2[[2]],
  chm_b3[[2]],
  chm_b4[[2]],
  chm_b5[[2]],
  chm_b6[[2]],
  filename = mosaicname,
  wopt = list(gdal = c("COMPRESS=LZW", "TFW=YES")),
  overwrite = FALSE
  )
```

```{r eval=file.exists(mosaicname)}
chm_mosaic <- rast(mosaicname)
plot(chm_mosaic)
```

```{r eval=FALSE}
differences <-
  chm_mosaic - terra::resample(Ename_20200831_vh25, chm_mosaic)
hist(differences)
plot(abs(differences) > 1)
```

# Structuurvariatie binnen plots van 6 m diameter

-   plotniveau: maat voor variatie in structuur binnen de plot
    -   obv CHM
    -   obv combinatie CHM en NDVI

In @smith2021 staat een tabel met mogelijke metrieken voor structuurvariatie.
Veel van deze metrieken reflecteren min of meer hetzelfde en ze zijn dan ook onderling vaak sterk gecorreleerd.

@smith2021 deelt de verschillende metrieken in in vier categorieën: 

- roughness
- distribution
- radial
- angular

De categorie "roughness" omvat metrieken die de "ruwheid" van het landschap weergeven.
Hier valt dan ook bijvoorbeeld de welgekende standaardafwijking onder.

De categorie "distribution" vertelt iets over de manier waarop de waarden (in ons geval hoogtemetingen) verdeeld zijn.
Hier valt bijvoorbeeld een maat voor scheefheid (skewness) onder.

De andere twee categorieën omvatten metrieken die iets zeggen over de (dominante) richting (Noord, Zuid, ...) waar een fenomeen zich voordoet.

Vooral "roughness" en "distribution" zijn relevant voor de karakterisatie van structuurvariatie op plotniveau.
We raden daarom aan om de statistisch welgekende metrieken te nemen, zijnde de standaardeviatie en de Fisher-Pearson coëfficiënt voor scheefheid om deze twee dimensies van structuurvariatie te vatten.

We raden aan om niet de namen hiervoor te gebruiken die @smith2021 hieraan toekennen (respectievelijk "root mean square roughness" en "surface skewness"), maar gewoon de naam te gebruiken waaronder ze in de statistiek gekend zijn.
Het is dan voor een lezer veel duidelijker wat er berekend wordt.

(ref:geodiv-table) Selectie uit metrieken van het `geodiv` R package [@smith2021]

```{r geodiv-table}
table_smith <- data.frame(
  stringsAsFactors = FALSE,
            Metric = c("Average roughness",
                       "Root mean square roughness","Ten-point height",
                       "Root mean square slope","Area root mean square slope",
                       "Surface area ratio","Surface bearing index", "Surface skewness", "Fractal dimension",
                       "Dominant texture direction","Texture direction index"),
     Function.name = c("Sa","Sq","S10z","Sdq",
                       "Sdq6","Sdr","Sbi", "Ssk", "Sfd","Std","Stdi"),
       Description = c("Absolute deviation of values from the mean value",
                       "Standard deviation of surface values relative to the mean value",
                       "Average height above the mean surface for the five highest local maxima plus the average height below the mean surface for the five lowest local minima",
                       "Root mean square slope using the two-point method",
                       "Root mean square slope using the seven-point method","Ratio of a flat surface to the actual surface",
                       "Ratio of root mean square roughness (Sq) to height at 5% of the bearing area curve",
                       "FisherPearson coefficient of skewness (asymmetry of the surface height distribution)",
                       "3D fractal dimension, calculated using the triangular prism surface area method.",
                       "Angle of dominating texture as found from the Fourier spectrum image","Relative dominance of Std"),
          Category = c("Roughness","Roughness",
                       "Roughness","Roughness","Roughness","Roughness",
                       "Distribution", "Distribution",
                       "Radial","Angular","Angular")
)

table_smith %>%
  kable(caption = "(ref:geodiv-table)")
```

Naast de keuze tussen metrieken is ook een keuze nodig wat te doen met eventuele grootschalige trends die in de kaart aanwezig zijn.
Indien deze grootschalige trends op zich niet interessant zijn, kan er een detrending gedaan worden alvorens de metrieken te berekenen (op de afwijkingen ten opzichte van de grootschalige trends).

Voor de CHM modellen is "detrending" vermoedelijk niet nodig.
Trends in maaiveldhoogte zijn immers al verwijderd doordat CHM = DSM - DTM.


## CHM

```{r skewness-functie}
ssk <- function(x, ...) {
  xbar <- mean(x, ...)
  s <- sd(x, ...)
  N <- length(na.omit(x))

  val_unadj <- (sum((x - xbar) ^ 3, ...) / N) / (s ^ 3)

  val <- (sqrt((N * (N - 1))) / (N - 2)) * val_unadj # adjusted Fisher-Pearson coefficient of skewness
  return(val)
}

ssk_extract <- function(value, coverage_fraction, ...) {
  xbar <- weighted.mean(x = value, w = coverage_fraction, ...)
  s <- sqrt(Hmisc::wtd.var(x = value, weights = coverage_fraction, ...))
  N <- length(na.omit(value))

  val_unadj <- (sum((value * coverage_fraction - xbar) ^ 3, ...) / N) /
    (s ^ 3)

  val <- (sqrt((N * (N - 1))) / (N - 2)) * val_unadj # adjusted Fisher-Pearson coefficient of skewness
  return(val)
}

```


```{r summarystats-chm-plot}
out <- exactextractr::exact_extract(
  chm_mosaic,
  pb_plot,
  fun = c("mean", "stdev", "coefficient_of_variation",
          "min", "quantile", "max"),
  quantiles = c(0.25, 0.75)
)

ssk_out <- exactextractr::exact_extract(
  chm_mosaic,
  pb_plot,
  fun = ssk_extract,
  na.rm = TRUE
)

pb_plot_chm <- pb_plot %>%
  bind_cols(out) %>%
  bind_cols(data.frame(ssk = ssk_out))
```


```{r mean-sd}
pb_plot_chm %>%
  ggplot() +
  geom_point(aes(x = mean, y = stdev))
```


```{r mean-cv}
pb_plot_chm %>%
  ggplot() +
  geom_point(aes(x = mean, y = coefficient_of_variation))
```

```{r mean-ssk}
pb_plot_chm %>%
  ggplot() +
  geom_point(aes(x = mean, y = ssk))
```



Standaarddeviatie = goede maat voor absolute variabiliteit in vegetatiehoogte in een proefvlak (maat voor de spreiding van vegetatiehoogtemetingen)

CV = goede maat voor verschillen in variabiliteit tussen proefvlakken

Scheefheid = 

- 0: geen scheve verdeling (symmetrische verdeling).
- < 0: negatieve scheefheid (piek zit rechts van het gemiddelde).
- > 0: positieve scheefheid (piek zit links van het gemiddelde).

```{r visualisatie-proefvlakken, fig.height = 220/25.4}
proefvlakken <- pb_plot_chm %>%
  group_by(gebied, code_plot, nr, start_staal, mean, stdev, 
           coefficient_of_variation, min, q25, q75, max, ssk) %>%
  nest() %>%
  mutate(
    plotchm = map(data, function(x){
      terra::crop(chm_mosaic, vect(x), mask = TRUE) %>%
        st_as_stars()
      }
    ),
    ggplots = pmap(list(code_plot = code_plot,
                        mean = mean,
                        stdev = stdev,
                        cv = coefficient_of_variation,
                        ssk = ssk,
                        plotchm = plotchm),
                   function(code_plot, mean, stdev, cv, ssk, plotchm) {
                     ggplot() +
                       geom_stars(data = plotchm) +
                       theme_void() +
                       coord_equal() +
                       labs(
                         title = code_plot,
                         subtitle = sprintf(
                           "mean = %.2f,\nstdev = %.2f,\ncv = %.2f,\nssk = %.2f",
                           mean,
                           stdev,
                           cv,
                           ssk))
                   })
    
  )


patchwork::wrap_plots(
  proefvlakken$ggplots, ncol = 3, guides = "collect") &
  scale_fill_viridis_c(
    breaks = c(0, 0.2, 0.5, 1, 1.5, 2),
    limits = c(-0.2, 2)
  )
```

```{r ecdf}
values <- exactextractr::exact_extract(
  chm_mosaic,
  pb_plot,
  include_cols = "code_plot",
  include_area = TRUE) %>%
  bind_rows() %>%
  as_tibble()

values %>%
  ggplot() +
  stat_ecdf(aes(x = value, colour = code_plot)) +
  labs(x = "Vegetatiehoogte (m)",
       y = "Proportie metingen kleiner dan vegetatiehoogte")
```

```{r densityplots}
values %>%
  ggplot() +
  geom_density(aes(x = value, colour = code_plot)) +
  labs(x = "Vegetatiehoogte (m)",
       y = "Densiteit aan metingen")
```


## CHM + NDVI

```{r calc-ndvi}
ndvi_res <- 0.25

ndvi_b1 <- calc_ndvi(dsm = Ename_20200831_DEM_Blok1,
                     target_resolution = ndvi_res,
                     overwrite = FALSE)
ndvi_b2 <- calc_ndvi(dsm = Ename_20200831_DEM_Blok2,
                     target_resolution = ndvi_res,
                     overwrite = FALSE)
ndvi_b3 <- calc_ndvi(dsm = Ename_20200831_DEM_Blok3,
                     target_resolution = ndvi_res,
                     overwrite = FALSE)
ndvi_b4 <- calc_ndvi(dsm = Ename_20200831_DEM_Blok4,
                     target_resolution = ndvi_res,
                     overwrite = FALSE)
ndvi_b5 <- calc_ndvi(dsm = Ename_20200831_DEM_Blok5,
                     target_resolution = ndvi_res,
                     overwrite = FALSE)
ndvi_b6 <- calc_ndvi(dsm = Ename_20200831_DEM_Blok6,
                     target_resolution = ndvi_res,
                     overwrite = FALSE)

```


```{r}
ndvimosaicname <- file.path(get_map_procesbeheer(),
                       "PB06_Drone_En_Beelden",
                       "PB_afgeleide_data",
                       "ndvi",
                       paste0("Ename_20200831_NDVI_mosaic",
                              "_res",
                              "0.25",
                              ".tif"))

```

```{r ndvi-mosaic-res0.25, eval=!file.exists(ndvimosaicname)}
terra::mosaic(
  ndvi_b1,
  ndvi_b2,
  ndvi_b3,
  ndvi_b4,
  ndvi_b5,
  ndvi_b6,
  filename = ndvimosaicname,
  wopt = list(gdal = c("COMPRESS=LZW", "TFW=YES")),
  overwrite = FALSE
  )
```

```{r eval=file.exists(ndvimosaicname)}
ndvi_mosaic <- rast(ndvimosaicname)
plot(ndvi_mosaic)
```

```{r points1000}
set.seed(12)
sample1000 <- pb_onderzoeksgebied %>%
  st_sample(size = 1000, type = "hexagonal") %>%
  st_as_sf() %>%
  mutate(pointid = row_number())

names(ndvi_mosaic) <- "ndvi"

ndvi_df <- terra::extract(
  ndvi_mosaic,
  sample1000)

names(chm_mosaic) <- "chm"

chm_df <- terra::extract(chm_mosaic, sample1000)

ndvi_chm_df <- ndvi_df %>%
  inner_join(chm_df, by = "ID") %>%
  as_tibble()


```

```{r fc3m-1000}
set.seed(12)
fc3m_1000 <- pb_onderzoeksgebied %>%
  st_sample(size = 1000, type = "hexagonal") %>%
  st_as_sf() %>%
  st_buffer(dist = 3) %>%
  mutate(pointid = row_number())

names(ndvi_mosaic) <- "ndvi"

fc3m_ndvi_df <- exactextractr::exact_extract(
  ndvi_mosaic,
  fc3m_1000,
  fun = "mean",
  force_df = TRUE,
  append_cols = "pointid")

names(chm_mosaic) <- "chm"

fc3m_chm_df <- exactextractr::exact_extract(
  chm_mosaic,
  fc3m_1000,
  fun = "mean",
  force_df = TRUE,
  append_cols = "pointid")

fc3m_ndvi_chm_df <- fc3m_ndvi_df %>%
  rename(mean_ndvi = mean) %>%
  inner_join(fc3m_chm_df %>%
               rename(mean_chm = mean),
             by = "pointid") %>%
  as_tibble()


```


```{r ndvi-chm-pointwise}
ndvi_chm_df %>%
  ggplot() + 
  geom_point(aes(x = ndvi, y = chm))

ndvi_chm_df %>%
  filter(ndvi > 0, chm > 0) %>%
  ggplot(aes(x = ndvi, y = chm)) + 
  geom_point() +
  geom_smooth() +
  scale_y_log10()

ndvi_chm_df %>%
  filter(ndvi > 0, chm > 0) %>%
  ggplot(aes(x = chm, y = ndvi)) + 
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_log10()

```


```{r ndvi-chm-circlewise}
fc3m_ndvi_chm_df %>%
  ggplot() + 
  geom_point(aes(x = mean_ndvi, y = mean_chm))

fc3m_ndvi_chm_df %>%
  filter(mean_ndvi > 0, mean_chm > 0) %>%
  ggplot(aes(x = mean_ndvi, y = mean_chm)) + 
  geom_point() +
  geom_smooth() +
  scale_y_log10()

fc3m_ndvi_chm_df %>%
  filter(mean_ndvi > 0, mean_chm > 0) %>%
  ggplot(aes(x = mean_chm, y = mean_ndvi)) + 
  geom_point() +
  geom_smooth(method = "lm") +
  scale_x_log10()

```


# Gebiedsdekkende structuurkaart

-   gebiedsniveau: een kaart die de structuur weergeeft


## CHM



```{r focal-function}

my_focal <- function(filename, ...) {
  if (file.exists(filename)) {
    terra::rast(filename)
  } else {
    terra::focal(filename = filename, ...)
  }
  
}

```


```{r}
# probeer hetzelfde als geodiv::texture_image, maar met terra
# het lijkt efficiënter om terra::focal te gebruiken, evt 
# in combinatie met summary functions van geodiv
circle3 <- focalMat(chm_mosaic,
                    d = 3,
                    type = "circle",
                    fillNA = TRUE)
circle3[!is.na(circle3)] <- 1

# 5 minuutjes
chm_mosaic_fcircle3_sd <- my_focal(
  x = chm_mosaic,
  w = circle3,
  fun = sd,
  na.rm = TRUE,
  filename = file.path(map_procesbeheer,
                       "PB06_Drone_En_Beelden",
                       "PB_afgeleide_data",
                       "chm",
                       paste0("Ename_20200831_CHM_mosaic",
                              "_res",
                              "0.25",
                              "_fcircle3m_sd.tif")),
  overwrite = FALSE)


chm_mosaic_fcircle3_skewness <- my_focal(
  x = chm_mosaic,
  w = circle3,
  fun = ssk,
  na.rm = TRUE,
  filename = file.path(map_procesbeheer,
                       "PB06_Drone_En_Beelden",
                       "PB_afgeleide_data",
                       "chm",
                       paste0("Ename_20200831_CHM_mosaic",
                              "_res",
                              "0.25",
                              "_fcircle3m_ssk.tif")),
  silent = FALSE,
  overwrite = FALSE)
```

De kaarten tonen nu dezelfde info als we berekend hebben voor de structuurvariatie in een proefvlak.
Elke pixel in de kaart geeft dus de waarde van de standaardafwijking of de scheefheid in een cirkel van 3 meter straal rond deze pixel (de resolutie is 25 cm x 25 cm).

Een andere straal kiezen zal een andere kaart opleveren.
Het is ook mogelijk om bijvoorbeeld een vierkant "moving window" te nemen in plaats van een cirkelvormig, dat resulteert in snellere berekeningen.
Een andere optie is een weging toepassen waarbij cellen dichtbij een groter gewicht krijgen dan cellen verderaf.
Voor de vergelijkbaarheid met de structuurvariatie op proefvlakniveau, lijkt het echter niet verkeerd om dezelfde 3 m straal cirkel te nemen als "moving window".

(ref:kaart-sd) Kaart van structuurvariatie op basis van standaardafwijking in cirkel met straal 3 m (eenheid is meter)

```{r kaart-sd, fig.cap = "(ref:kaart-sd)"}
plot(chm_mosaic_fcircle3_sd)
```

(ref:kaart-ssk) Kaart van structuurvariatie op basis van maat voor scheefheid in cirkel met straal 3 m. In de tweede kaart zijn de waarden kleiner dan -1 op -1 gezet, waarden tussen -1 en 1 op 0 en waarden groter dan 1 op 1.


```{r kaart-ssk, fig.cap = "(ref:kaart-ssk)"}
plot(chm_mosaic_fcircle3_skewness)


plot(classify(chm_mosaic_fcircle3_skewness,
              rcl = data.frame(
                from = c(-Inf, -1, 1),
                to = c(-1, 1, +Inf),
                becomes = c(-1, 0, 1))))
```


## CHM + NDVI



## Classificatie

Mogelijke pistes:

- gebiedsdekkende structuurkaarten op basis van de metrieken (sd, ssk) indelen via thresholds

- rechtstreeks op de kaarten met vegetatiehoogtes en ndvi een classificatie uitvoeren via één of ander algorithme (k-means of SOM lijken voor de hand liggende opties) en daarna de clusterkenmerken karakteriseren door achteraf metrieken (sd, ssk) te berekenen



# Referenties
